<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3.2 RAG | Skeinz&#39;s page</title>
    
<link rel="stylesheet" href="/css/style.css">

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          TeX: {
            extensions: ["amsmath.js", "cancel.js"],
          }
        });
    </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div class="container">
        <header class="post-navbar">
    <a href="/" class="nav-left">
        <img src="/img/avatar.jpg" alt="Avatar" class="nav-avatar">
        <span class="nav-title">上下求索</span>
    </a>

    <div class="nav-right">
        <div class="nav-item search-trigger">
            <img src="/img/icons/search.svg" alt="Search" class="search-icon">
            <span>请输入关键词搜索...</span>
        </div>

        <a href="/notes/" class="nav-link">笔记导航</a>

        <div class="nav-item theme-switcher">
            <img src="/img/icons/sun.svg" alt="Sun" class="sun-icon">
            <img src="/img/icons/moon.svg" alt="Moon" class="moon-icon">
        </div>
    </div>
</header>

<div id="search-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <input type="text" id="search-input" placeholder="输入关键字搜索...">
        <div id="search-results"></div>
    </div>
</div>
<div class="post-layout">
  <aside class="post-sidebar">
    
    
      
      <nav>
          <div class="sidebar-top">
              <!-- <a href="/" class="back-to-home-link" style="display: flex; align-items: center">
                  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m15 18l-6-6l6-6"/></svg>
                  <span>返回首页</span>
              </a> -->
              <h3>大语言模型</h3>
          </div>
          <ul>
              
                  <li class="sidebar-group">
                      <details open>
                          <summary>
                              <svg class="sidebar-arrow" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="m15.5 12.001l-5.75 5.75c-.15.15-.325.225-.525.225s-.375-.075-.525-.225c-.3-.3-.3-.775 0-1.075l5.225-5.25l-5.225-5.25c-.3-.3-.3-.775 0-1.075s.775-.3 1.075 0l5.75 5.75c.15.15.225.325.225.525s-.075.375-.225.525Z"/></svg>
                              <span class="sidebar-summary-text">1 强化学习</span>
                          </summary>
                          <div class="details-content">
                              <ul>
                                  
                                      <li class="sidebar-item ">
                                          <a href="/notes/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/1.1-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/">1.1 Q-Learning</a>
                                      </li>
                                  
                              </ul>
                          </div>
                      </details>
                  </li>
              
                  <li class="sidebar-group">
                      <details open>
                          <summary>
                              <svg class="sidebar-arrow" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="m15.5 12.001l-5.75 5.75c-.15.15-.325.225-.525.225s-.375-.075-.525-.225c-.3-.3-.3-.775 0-1.075l5.225-5.25l-5.225-5.25c-.3-.3-.3-.775 0-1.075s.775-.3 1.075 0l5.75 5.75c.15.15.225.325.225.525s-.075.375-.225.525Z"/></svg>
                              <span class="sidebar-summary-text">2 构建一个大模型</span>
                          </summary>
                          <div class="details-content">
                              <ul>
                                  
                                      <li class="sidebar-item ">
                                          <a href="/notes/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/2.1-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%A2%84%E8%AE%AD%E7%BB%83/">1.1 预训练</a>
                                      </li>
                                  
                              </ul>
                          </div>
                      </details>
                  </li>
              
                  <li class="sidebar-group">
                      <details open>
                          <summary>
                              <svg class="sidebar-arrow" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="m15.5 12.001l-5.75 5.75c-.15.15-.325.225-.525.225s-.375-.075-.525-.225c-.3-.3-.3-.775 0-1.075l5.225-5.25l-5.225-5.25c-.3-.3-.3-.775 0-1.075s.775-.3 1.075 0l5.75 5.75c.15.15.225.325.225.525s-.075.375-.225.525Z"/></svg>
                              <span class="sidebar-summary-text">3 应用开发</span>
                          </summary>
                          <div class="details-content">
                              <ul>
                                  
                                      <li class="sidebar-item ">
                                          <a href="/notes/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/3.1-LangChain/">3.1 LangChain简介</a>
                                      </li>
                                  
                                      <li class="sidebar-item active">
                                          <a href="/notes/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/3.2-RAG/">3.2 RAG</a>
                                      </li>
                                  
                                      <li class="sidebar-item ">
                                          <a href="/notes/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/3.3-Agent/">3.3 Agent</a>
                                      </li>
                                  
                              </ul>
                          </div>
                      </details>
                  </li>
              
          </ul>
      </nav>
    
  </aside>

  <article class="post-content">
    

    <h1>3.2 RAG</h1>
    <!-- <div class="post-meta">
      
        <time class="post-date-tag" datetime="2025-09-15T16:00:00.000Z">
            发布于: 2025-09-16
        </time>
      
    </div> -->
    <div class="post-body">
        <h1 id="1-检索增强生成">1 检索增强生成</h1>
<ul>
<li><strong>R</strong>etrieval-<strong>A</strong>ugmented <strong>G</strong>eneration</li>
</ul>
<p>你正在看一份文档敲代码，毫无疑问地，你遇到了问题，现在你将这个问题抛给AI大模型，即便大模型从来都没见过你的这份文档（大模型的<strong>知识冻结</strong>），但大模型仍然会一本正经地胡说八道，出现了<strong>幻觉</strong>。没有得到你想要的答案，于是你将问题和答案一起抛给大模型，这次就给出了正确的回答。</p>
<p>问题似乎解决了，但你的文档会变得越来越大，关键的信息只会藏在其中的某一角落里，大模型看了整个文档之后注意力难免也会涣散。那么能不能把文档中相关的部分发给大模型呢？答案是肯定的，这就是RAG想要解决的问题。现在的难题就是：<u>如何判断文档中的某一部分和你的问题是否相关</u>。</p>
<h2 id="1-1-嵌入模型">1.1 嵌入模型</h2>
<ul>
<li>Embedding Model，输入一段文字，输出一段<strong>固定长度</strong>的向量，如OpenAI的text-embedding-3-small模型输出的数组长度为1536，对应的large模型就是small模型的2倍。无论你的信息有多长，信息都被压缩到固定维度的向量中了。最后，可以通过计算向量之间的距离来判断两个信息之间的关联度。向量空间的维度足够大，能够将各种信息的向量距离区分开。</li>
<li>接下来，你的问题经过Embedding模型的压缩，被映射到向量空间上的某一个位置上，得到距离你的问题最近的几段文字当作上下文，和你的问题一起发给大模型。于是大模型看到的就是和你的问题强相关的信息了。</li>
</ul>
<p>我们的目的是找到整个文档中与你的问题相关的部分，那么文档该如何切分成更小的单元呢？可以按字数、段落、句子来切分。经过文字分块（chunking）之后，每一块文字都做一个Embedding，并将得到的向量与文字片段对应起来。</p>
<ul>
<li>现成的分块算法：LangChain中的Recursive Character Text Splitter</li>
</ul>
<p>传统的数据库用键值对的方式来存储这种对应关系，但我们并不是想通过精确的key值来查找对应的向量或文本，而是要找距离问题向量最近的几个向量对应的文本，这时候传统的数据库就不行了。针对这种场景，专门设计了向量数据库。</p>
<h2 id="1-2-向量数据库">1.2 向量数据库</h2>
<ul>
<li>存储结构当然是嵌入向量和对应的文本</li>
<li>常见的有Pinecone，chromaDB，postgreSQL（配合pgvector插件）等</li>
</ul>
<h2 id="1-3-总结">1.3 总结</h2>
<p>RAG并不是一个完美的框架</p>
<ul>
<li>文本的结构不同，文本怎么分块，无法适配所有的场景。比如将两句相关的句子切分了，导致二者不关联。</li>
<li>没有全局的视角，比如我要统计一篇文档中出现了多少个某单词，这种整体都沾边的问题RAG是无法处理的</li>
</ul>
<p>改进：让大模型参与分块的过程，根据语义自动判断应该在哪里断开…</p>
<div align=center><img src="https://raw.gitmirror.com/inferiorStudent/resource-CDN/main/llm/rag-process.svg"></div>
<p>总结下来，构建一个RAG主要有两步：构建向量数据库、用户请求查询。图中绿色方块都是LangChain架构中的方法（载入文档为文本内容、文本分割、嵌入…）。</p>
<ul>
<li>
<p>如图灰色方块流程：构建向量数据库</p>
</li>
<li>
<p>如图蓝色方块流程：用户请求，放到向量数据库中匹配，采用top-k的方法取出相近含义的内容打包为提示词一起发送给大模型</p>
</li>
</ul>
<h1 id="2-实现一个RAG">2 实现一个RAG</h1>
<h2 id="2-1-构建">2.1 构建</h2>
<p>首先导入必要的包。数据库、嵌入模型、分词模型就不从零实现了，直接调包</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> DirectoryLoader, TextLoader<br><span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> MarkdownHeaderTextSplitter<br><span class="hljs-keyword">from</span> langchain_community.embeddings <span class="hljs-keyword">import</span> HuggingFaceBgeEmbeddings<br><span class="hljs-keyword">from</span> langchain_community.vectorstores <span class="hljs-keyword">import</span> FAISS<br><br>EMBEDDING_MODEL_LOCAL_PATH = <span class="hljs-string">&quot;./embedding_model/text2vec-base-chinese&quot;</span><br>VECTOR_DB_PATH = <span class="hljs-string">&quot;./vector_db&quot;</span><br>KNOWLEDGE_BASE_DIR = <span class="hljs-string">&quot;./knowledge_base&quot;</span><br></code></pre></td></tr></table></figure>
<p>为了避免联网下载嵌入模型，我们首先到hugging face上下载某一个嵌入模型到本地的<code>embedding_model</code>文件夹中，这里就以<code>shibing624/text2vec-base-chinese</code>嵌入模型为例。</p>
<p>设置向量数据库的存放位置以及知识库文档的位置。我们首先要构建高质量的markdown格式的知识文档，统一格式（下面的方法采用一级标题、二级标题和正文的格式）以便实现切分。下面的代码中是将<code>KNOWLEDGE_BASE_DIR</code>下的所有markdown文档加载并切分，再嵌入到数据库当中的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_vector_db</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; 构建向量数据库（知识库）</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(EMBEDDING_MODEL_LOCAL_PATH):<br>        <span class="hljs-keyword">raise</span> FileNotFoundError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;EMBEDDING_MODEL_LOCAL_PATH&#125;</span> 不存在本地嵌入模型，请先到hugging face上下载&quot;</span>)<br>    <br>    <span class="hljs-comment"># 加载知识库的所有文件 (markdown格式 AI更好辨认)</span><br>    loader = DirectoryLoader(<br>        KNOWLEDGE_BASE_DIR,<br>        glob=<span class="hljs-string">&quot;**/*.md&quot;</span>,<br>        loader_cls=TextLoader,<br>        loader_kwargs=&#123;<span class="hljs-string">&quot;encoding&quot;</span>: <span class="hljs-string">&quot;utf-8&quot;</span>&#125;,<br>        show_progress=<span class="hljs-literal">True</span>,<br>    )<br>    documents = loader.load()<br><br>    <span class="hljs-comment"># 文本切分</span><br>    headers_to_split_on = [(<span class="hljs-string">&quot;#&quot;</span>, <span class="hljs-string">&quot;Header 1&quot;</span>), (<span class="hljs-string">&quot;##&quot;</span>, <span class="hljs-string">&quot;Header 2&quot;</span>)]<br>    markdown_spliter = MarkdownHeaderTextSplitter(headers_to_split_on=headers_to_split_on)<br><br>    docs_splitted = []<br>    <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> documents:<br>        docs_splitted.extend(markdown_spliter.split_text(doc.page_content))<br>    <br>    <span class="hljs-built_in">print</span>(docs_splitted)<br><br>    <span class="hljs-comment"># 加载嵌入模型</span><br>    embeddings = HuggingFaceBgeEmbeddings(model_name=EMBEDDING_MODEL_LOCAL_PATH)<br><br>    <span class="hljs-comment"># 将文本嵌入为向量 并存储到向量数据库中</span><br>    vector_db = FAISS.from_documents(docs_splitted, embedding=embeddings)<br>    vector_db.save_local(VECTOR_DB_PATH)<br></code></pre></td></tr></table></figure>
<p>执行上述函数，会生成<code>index.faiss</code>和<code>index.pkl</code>两个文件</p>
<h2 id="2-2-查询">2.2 查询</h2>
<p>接下来，采用<strong>单例模式</strong>写一个检索向量数据库的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Retriever</span>:<br>    _instance = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cls._instance:<br>            cls._instance = <span class="hljs-built_in">super</span>(Retriever, cls).__new__(cls)<br>        <span class="hljs-keyword">return</span> cls._instance<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(<span class="hljs-variable language_">self</span>, <span class="hljs-string">&#x27;vector_db&#x27;</span>):<br>            <span class="hljs-keyword">return</span><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(VECTOR_DB_PATH):<br>            <span class="hljs-keyword">raise</span> FileNotFoundError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;VECTOR_DB_PATH&#125;</span> 不存在向量数据库&quot;</span>)<br>        <br>        <span class="hljs-keyword">try</span>:<br>            embeddings = HuggingFaceBgeEmbeddings(model_name=EMBEDDING_MODEL_LOCAL_PATH)<br>            <span class="hljs-variable language_">self</span>.vector_db = FAISS.load_local(<br>                VECTOR_DB_PATH,<br>                embeddings=embeddings,<br>                allow_dangerous_deserialization=<span class="hljs-literal">True</span>,<br>            )<br>            <span class="hljs-variable language_">self</span>.retriever = <span class="hljs-variable language_">self</span>.vector_db.as_retriever(search_kwargs=&#123;<span class="hljs-string">&quot;k&quot;</span>: <span class="hljs-number">3</span>&#125;)    <span class="hljs-comment"># top-k</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-variable language_">self</span>.vector_db = <span class="hljs-literal">None</span><br>            <span class="hljs-variable language_">self</span>.retriever = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.retriever:<br>            <span class="hljs-keyword">return</span> []<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.retriever.invoke(query)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_retriever</span>() -&gt; Retriever:<br>    <span class="hljs-keyword">return</span> Retriever()<br></code></pre></td></tr></table></figure>
<p>首先，检查相关文件是否存在。接下来，导入本地嵌入模型、向量数据库，设置top-k，也就是查询语义相近的k条数据。最后，使用FAISS给的方法查询和query语义相近的k条Document，返回的是Document数据类型的列表。每个向量数据库所给的方法不尽相同，但流程都是一样的。</p>
<p>接着，在别的地方调用这个方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    retriever = get_retriever()<br>    retriever_docs = retriever.search(<span class="hljs-string">&quot;你的询问&quot;</span>)<br>    <span class="hljs-built_in">print</span>(retriever_docs)<br></code></pre></td></tr></table></figure>
<p>查询出来的列表中的数据有如下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Document(id=&#x27;08b0e244-4fd3-4728-ab3b-4817baf11a7f&#x27;, metadata=&#123;xxx&#125;, page_content=&#x27;xxx&#x27;)<br></code></pre></td></tr></table></figure>

    </div>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const codeBlocks = document.querySelectorAll('figure.highlight');
    
        codeBlocks.forEach(block => {
            // 1. 获取语言标签
            const lang = block.classList.contains('highlight') ? 
                         block.classList[1] : '';
    
            // 2. 创建一个容器来包裹语言标签和复制按钮
            const toolbar = document.createElement('div');
            toolbar.className = 'highlight-toolbar';
    
            // 3. 创建语言标签
            if (lang) {
                const langLabel = document.createElement('span');
                langLabel.className = 'highlight-lang';
                langLabel.textContent = lang.toUpperCase();
                toolbar.appendChild(langLabel);
            }
    
            // 4. 创建复制按钮
            const copyButton = document.createElement('button');
            copyButton.className = 'highlight-copy-btn';
            copyButton.textContent = '复制';
            
            copyButton.addEventListener('click', () => {
                // 优先选择 .code 元素（针对有行号的表格），如果没有则选择 pre 元素
                const codeElement = block.querySelector('.code') || block.querySelector('pre');
                if (codeElement) {
                    navigator.clipboard.writeText(codeElement.textContent).then(() => {
                        copyButton.textContent = '已复制!';
                        setTimeout(() => {
                            copyButton.textContent = '复制';
                        }, 2000);
                    }).catch(err => {
                        console.error('复制失败: ', err);
                    });
                }
            });
            toolbar.appendChild(copyButton);
    
            // 5. 将工具栏插入到代码块中
            block.appendChild(toolbar);
        });
    });
</script>
  </article>
</div>

    </div>
    
<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>